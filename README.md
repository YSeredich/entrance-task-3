# Задание 3

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать, 
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл. 
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.

## Исправление бага:
Так как до выполнения задания не была знакома с сервис воркерами, начала с прочтения рекомендованной статьи на MDN. При прочтении статьи заметила, что автор несколько раз акцентировал свое внимание на максимальном scope ServiceWorker.
Запустив проект не обнаружила сообщений о том, что ServiceWorker установлен и активирован. Прочла другую статью, узнала что у ServiceWorker есть своя консоль и увидела в ней [ServiceWorker] Installed! и [ServiceWorker] Activated!
После более детального изучения кода ServiceWorker и пары неудачных предположений, вспомнила о рефакторинге “разложить файлы красиво” в совокупности с ограничениями для scope ServiceWorker . Поняла, что ServiceWorker не может обработать файлы, которые лежат вне assets. Стало ясно, что нужно либо переместить ServiceWorker в корень либо все файлы, на которые он должен влиять в assets. Решение было принято в пользу перемещения ServiceWorker, так как:
во-первых, кажется, что это довольно важный файл, который влияет на работу всего сайта и он может лежать в корне,
во-вторых нужно кешировать файл gifs.html, а идея перемещать его куда-либо из корня мне не нравится,
в-третьих, безопаснее переместить один файл и переписать пути в нем и до него, чем сделать это с большим количеством файлов.
Итак, ServiceWorker перемещаю в корень, заменив все нужные пути.
Вспоминаю про проблемы с кешированием html, вижу что в кеше есть ключи с media (гифки) есть jquery, но нет gifs.html. Нахожу в коде ServiceWorker функцию, которая фильтрует, что требует кеширования, а что нет. Сперва добавляю includes('gifs') и понимаю, что не могу больше найти ничего, так как мой поисковой запрос "самолеты" закешировался. Меняю на endsWith('gifs.html') и проблема решена. Все здорово, избранное работает оффлайн, страничка кешируется.
Случай со случайно закешированным результатом поиска наводит на мысли о том, что такая ситуация может возникнуть где-нибудь ещё, смотрю подробнее в код 'fetch' и вижу там, что всегда предпочтителен кеш, мысли:
подумала о том, чтобы переписать наоборот, пусть всегда качает и сохраняет обновленную версию (но в чем смысл кешировать тогда? только ради оффлайна, а как же не загружать емкие файлы лишний раз?),
или переписать так чтобы у гифок и библиотек, например, в приоритете был кеш, а у всего остального скачивание, но потом вспомнила, что если кто-либо что-либо заменит, он должен поменять версию кеша и все обновится.
Еще поэкспериментировав с гифками заметила, что если я ищу что-либо, затем добавляю гифку в избранное, потому убираю её из избранного, потом делаю оффлайн-режим, вижу страничку с результатом поиска, все гифки не загрузились, кроме той, которая когда-то была в избранном, хотя её уже в избранном нет. Вижу, что удаляется ключ на нее в избранном, но сама она остается закешированная. Думаю баг ли это и решаю, в пользу преимущества. Спасибо, что прочли этот длинный текст.

## Ответы на вопросы в коде ServiceWorker:

### Вопрос №1: зачем нужен этот вызов?
.then(() => self.skipWaiting())
Ответ: Переводит service worker из стадии ожидания в активную стадию немедленно,
не дожидаясь загрузки страниц на которых он задействован.

### Вопрос №2: зачем нужен этот вызов?
self.clients.claim();
Ответ: Текущий service worker начинает контролировать все открытые страницы без их перезагрузки.

Парная работа этих методов гарантирует, что при изменениях в основном service worker они немедленно
отобразятся на всех страницах, на которых он задействован.

### Вопрос №3: для всех ли случаев подойдёт такое построение ключа?
const cacheKey = url.origin + url.pathname;
Ответ: в данной реализации для всех, но если мы захотим кешировать
что-либо, содержащее в своем url query string, например результаты поиска гифок, то ключ будет
генерироваться один и тот же, а следовательно резутаты перезаписывать друг друга.

### Вопрос №4: зачем нужна эта цепочка вызовов?
return Promise.all(
    names.filter(name => name !== CACHE_VERSION)
        .map(name => {
            console.log('[ServiceWorker] Deleting obsolete cache:', name);
            return caches.delete(name);
        })
);
Ответ: Чтобы в фазе активации точно знать, когда завершилось удаление старого кеша и можно двигаться дальше

### Вопрос №5: для чего нужно клонирование?
cache.put(cacheKey, response.clone());
Ответ: Нам нужно и закешировать response, и передать его браузеру.
Но прочесть response можно только один раз, поэтому нужно его клонировать.
